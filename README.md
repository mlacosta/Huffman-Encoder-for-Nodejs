<p align="center">
  <h3 align="center">Template for typescript applications</h3>

  <p align="center">
     ⚙ Template repository for typescript applications meant to run in node ⚙
    <br />
    <a href="https://github.com/gagoar/ts-node-template#table-of-contents"><strong>Explore the docs »</strong></a>
    <br />
    <a href="https://github.com/gagoar/ts-node-template/issues">Report Bug</a>
    ·
    <a href="https://github.com/gagoar/ts-node-template/issues">Request Feature</a>
  </p>
</p>

## Table of Contents

- [Built With](#built-with)
- [Getting Started](#getting-started)
- [Contributing](#contributing)
- [License](#license)

<!-- CONTRIBUTING -->

### Built With

- [ncc](https://github.com/vercel/ncc/)
- [jest](https://github.com/facebook/jest)
- [ora](https://github.com/sindresorhus/ora)
- [commander](https://github.com/tj/commander.js/)
- [cosmiconfig](https://github.com/davidtheclark/cosmiconfig)

## Huffman Compression

Huffman compression is a data encoding technique that uses a greedy approach for loseless compression based on how often a character or symbol occurs. Theoretically, It can achieve a compression rate between 20 and 90 percent.

First, suppose we have a set of 6 letters and the number of occurrence (frequency) for each one:

| letter | frequency |
| ------ | --------- |
| a      | 45        |
| b      | 13        |
| c      | 12        |
| d      | 16        |
| e      | 9         |
| f      | 5         |

Since we have 6 symbols, a naive approach would be to use a 3-bit encoding for each one of them:

| letter | bitstring |
| ------ | --------- |
| a      | 000       |
| b      | 001       |
| c      | 010       |
| d      | 011       |
| e      | 100       |
| f      | 101       |

For instance, if we want to encode the string 'decab' using the table from above:

```
'decab' transforms into '011100010000001'
```

Then, we can encode it further using a [base64](https://en.wikipedia.org/wiki/Base64) approach:

| binary (6-bits) | base64 (char) |
| --------------- | ------------- |
| 011100          | c             |
| 010000          | Q             |
| 011000          | I             |

```
'011100010000001' transforms into 'cQI='
```

In this case, the symbol `=` is used for zero-padding by convention.

Note this way of encoding could be served as a binary tree where each leaf represents a letter and its frequency. More generally, each node´s parent contains the summation of its children frequency and the combination of their symbols. Starting from the root, one could simply make a symbol search and output a `0` or `1` based on if you moved to the left or right respectively.

![](https://i.imgur.com/QM2laV5.jpg)

However, a better approach would be to create [prefix-efficient](https://en.wikipedia.org/wiki/Prefix_code) codes based on each letter's frequency. In that way, we could generate a variable-lenght encoding that depends of the number of occurrences (the more frequent a letter the shorter its representation). This results on a reduced bitstring on average. This particular way of operating is known as Huffman Compression:

First, we need to generate a node for each one of the letters. We can use a data structure like this:

```
{
  "symbol": 'a'
  "frequency": 45
}
```

Next, we combine all the nodes in a tree-like structure using a greedy algorithm that chooses between the least frequent symbol and merges them. In our example, we start with:

```
{
  "symbol": 'f'
  "frequency": 5
}

{
  "symbol": 'e'
  "frequency": 9
}
```

and we create the node:

```
{
  "symbol": 'fe'
  "frequency": 14
}
```

By induction, after all the nodes are merged, we would obtain a huffman tree that serves as our encoder:

![](https://i.imgur.com/roKnNFS.jpg)

The optimal way to implement this is using a min-heap data structure.

Note there's a trade-off between the huffman compression rate and the expansion generated by the base64 encoding that should be taken into consideration.

## Motivation

This library was originally inteded to be used as an url-friendly encoder/decoder. The idea was to process a chunk of text, compress the data and then embedded it in an url as a query parameter.

Later on, you can retreive the original piece of text using the

A typical application for this library is permalink creation and sharing. Using this

## Examples

## Contributing

Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make are greatly appreciated **greatly appreciated**.

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

<!-- LICENSE -->

## License

Distributed under the MIT License. See `LICENSE` for more information.
